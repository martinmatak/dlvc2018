import numpy as np
from .dataset import Dataset
from .ops import Op
import typing

IMAGE_WIDTH = 32
IMAGE_HEIGHT = 32
CHANNEL_NUM = 3


class Batch:
    '''
    A (mini)batch generated by the batch generator.
    '''

    def __init__(self):
        '''
        Ctor.
        '''

        self.data = None
        self.label = None
        self.idx = None


class BatchGenerator:
    '''
    Batch generator.
    Returned batches have the following properties:
      data: numpy array holding batch data of shape (s, SHAPE_OF_DATASET_SAMPLES).
      label: numpy array holding batch labels of shape (s, SHAPE_OF_DATASET_LABELS).
      idx: numpy array with shape (s,) encoding the indices of each sample in the original dataset.
    '''

    def __init__(self, dataset: Dataset, num: int, shuffle: bool, op: Op = None):
        '''
        Ctor.
        Dataset is the dataset to iterate over.
        num is the number of samples per batch. the number in the last batch might be smaller than that.
        shuffle controls whether the sample order should be preserved or not.
        op is an operation to apply to input samples.
        Raises TypeError on invalid argument types.
        Raises ValueError on invalid argument values, such as if num is > len(dataset).
        '''

        # dataset field
        if isinstance(dataset, Dataset):
            self.dataset = dataset
        else:
            raise TypeError("dataset has an inappropriate type.")

        # num field
        if isinstance(num, int):
            if num > len(dataset):
                raise ValueError("Number may not be grater than length of a dataset.")
            else:
                self.batch_size = num
        else:
            raise TypeError("num has an inappropriate type.")

        # shuffle field
        if isinstance(shuffle, bool):
            self.shuffle = shuffle
        else:
            raise TypeError("shuffle has an inappropriate type.")

        # op field
        if op is None:
            self.op = op
        elif callable(op):
            self.op = op
        else:
            raise TypeError("op has an inappropriate type.")

        # initialize indices
        if shuffle:
            self.indices = np.random.permutation(len(dataset))
        else:
            self.indices = np.arange(len(dataset))

    def __len__(self) -> int:
        '''
        Returns the number of batches generated per iteration.
        '''

        return int(np.ceil(len(self.dataset) / self.batch_size))

    def __iter__(self) -> typing.Iterable[Batch]:
        '''
        Iterate over the wrapped dataset, returning the data as batches.
        '''

        if self.op:
            sample_data_shape = self.op(self.dataset[0].data).shape
        else:
            sample_data_shape = self.dataset[0].data.shape

        data = np.zeros((self.batch_size,) + sample_data_shape, dtype=np.float32)

        sample_label_shape = self.dataset[0].label.shape
        labels = np.zeros((self.batch_size,) + sample_label_shape, dtype=np.uint8)

        indices = np.zeros(self.batch_size, dtype=np.int32)
        for idx in range(0, len(self)):
            sample_indices = self.indices[idx * self.batch_size:(idx + 1) * self.batch_size]

            # if last batch, reinitialize arrays to fit the batch size
            if idx == len(self)-1:
                data = np.zeros((len(sample_indices),) + sample_data_shape, dtype=np.float32)

                sample_label_shape = self.dataset[0].label.shape
                labels = np.zeros((len(sample_indices),) + sample_label_shape, dtype=np.uint8)

                indices = np.zeros(len(sample_indices), dtype=np.int32)

            for i, sample_id in enumerate(sample_indices):
                sample = self.dataset[sample_id]
                if self.op:
                    data[i] = self.op(sample.data)
                else:
                    data[i] = sample.data
                labels[i] = sample.label
                indices[i] = sample.idx
            batch = Batch()
            batch.data = data
            batch.label = labels
            batch.idx = indices
            yield batch
